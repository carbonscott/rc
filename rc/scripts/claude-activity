#!/usr/bin/env -S UV_CACHE_DIR=/sdf/data/lcls/ds/prj/prjdat21/results/cwang31/.UV_CACHE uv run --script
# /// script
# requires-python = ">=3.10"
# dependencies = ["textual>=0.90"]
# ///
"""Claude Activity Dashboard — see all your Claude sessions across tmux."""

from __future__ import annotations

import json
import os
import signal
import subprocess
from datetime import datetime
from pathlib import Path

from textual import on
from textual.app import App, ComposeResult
from textual.binding import Binding
from textual.containers import Vertical
from textual.screen import ModalScreen
from textual.widgets import (
    DataTable,
    Footer,
    Header,
    Input,
    Static,
    TabbedContent,
    TabPane,
)

CLAUDE_DIR = Path.home() / ".claude"
HISTORY_FILE = CLAUDE_DIR / "history.jsonl"
PROJECTS_DIR = CLAUDE_DIR / "projects"


def get_current_tmux_socket() -> str:
    """Get the current tmux socket name from $TMUX env var.
    Format: /tmp/tmux-UID/SOCKET,PID,N
    """
    tmux_env = os.environ.get("TMUX", "")
    if not tmux_env:
        return ""
    socket_path = tmux_env.split(",")[0]  # /tmp/tmux-18262/00
    return Path(socket_path).name  # 00


def copy_to_clipboard(text: str) -> bool:
    """Try to copy text to clipboard. Returns True on success."""
    for cmd in [["xclip", "-selection", "clipboard"],
                ["xsel", "--clipboard", "--input"],
                ["pbcopy"]]:
        try:
            subprocess.run(cmd, input=text.encode(), timeout=3,
                           capture_output=True, check=True)
            return True
        except Exception:
            continue
    # Try tmux's buffer as last resort
    try:
        subprocess.run(["tmux", "set-buffer", text],
                       timeout=3, capture_output=True, check=True)
        return True
    except Exception:
        return False


# ---------------------------------------------------------------------------
# Data collection
# ---------------------------------------------------------------------------

def get_uid() -> int:
    return os.getuid()


def get_tmux_sockets() -> list[str]:
    """Find all tmux sockets for the current user."""
    uid = get_uid()
    tmux_dir = Path(f"/tmp/tmux-{uid}")
    if not tmux_dir.is_dir():
        return []
    return [s.name for s in sorted(tmux_dir.iterdir()) if s.is_socket()]


def get_all_tmux_panes() -> dict[int, dict]:
    """Map pane shell PIDs to their tmux location across all sockets."""
    pane_map: dict[int, dict] = {}
    for sock in get_tmux_sockets():
        try:
            out = subprocess.run(
                ["tmux", "-L", sock, "list-panes", "-a",
                 "-F", "#{pane_pid}\t#{session_name}\t#{window_index}\t#{pane_index}"],
                capture_output=True, text=True, timeout=5,
            )
            for line in out.stdout.strip().splitlines():
                parts = line.split("\t")
                if len(parts) == 4:
                    pid = int(parts[0])
                    pane_map[pid] = {
                        "socket": sock,
                        "session": parts[1],
                        "window": parts[2],
                        "pane": parts[3],
                    }
        except Exception:
            continue
    return pane_map


def find_tmux_pane(pid: int, pane_map: dict[int, dict]) -> dict | None:
    """Walk the parent chain of a PID to find its tmux pane."""
    visited = set()
    current = pid
    for _ in range(15):
        if current in visited or current <= 1:
            break
        visited.add(current)
        if current in pane_map:
            return pane_map[current]
        try:
            status = Path(f"/proc/{current}/status").read_text()
            for line in status.splitlines():
                if line.startswith("PPid:"):
                    current = int(line.split()[1])
                    break
            else:
                break
        except Exception:
            break
    return None


def get_active_processes() -> list[dict]:
    """Find all running Claude processes with their directories and tmux panes."""
    uid = get_uid()
    try:
        out = subprocess.run(
            ["ps", "-u", str(uid), "-o", "pid,etime,comm", "--no-headers"],
            capture_output=True, text=True, timeout=5,
        )
    except Exception:
        return []

    claude_pids = []
    for line in out.stdout.strip().splitlines():
        parts = line.split()
        if len(parts) < 3:
            continue
        pid_str, etime = parts[0], parts[1]
        comm = " ".join(parts[2:])
        if "claude" in comm.lower() or "2.1." in comm:
            try:
                claude_pids.append((int(pid_str), etime, comm))
            except ValueError:
                continue

    pane_map = get_all_tmux_panes()
    results = []
    for pid, etime, comm in claude_pids:
        cwd = ""
        try:
            cwd = os.readlink(f"/proc/{pid}/cwd")
        except Exception:
            pass
        pane = find_tmux_pane(pid, pane_map)
        tmux_loc = ""
        if pane:
            tmux_loc = f"{pane['socket']}:{pane['session']}:{pane['window']}.{pane['pane']}"
        results.append({
            "pid": pid,
            "directory": cwd,
            "uptime": etime,
            "tmux": tmux_loc,
            "socket": pane["socket"] if pane else "",
            "target": f"{pane['session']}:{pane['window']}.{pane['pane']}" if pane else "",
        })
    return results


def shorten_path(path: str, max_len: int = 60) -> str:
    """Shorten a path for display, keeping the meaningful end."""
    if len(path) <= max_len:
        return path
    parts = path.split("/")
    # Try keeping last N components
    for n in range(len(parts), 0, -1):
        short = ".../" + "/".join(parts[-n:])
        if len(short) <= max_len:
            return short
    return path[-max_len:]


def get_recent_projects(limit: int = 30) -> list[dict]:
    """Parse history.jsonl for recent unique projects."""
    if not HISTORY_FILE.exists():
        return []
    projects: dict[str, dict] = {}
    for line in HISTORY_FILE.read_text().splitlines():
        try:
            entry = json.loads(line)
            proj = entry.get("project", "")
            ts = entry.get("timestamp", 0)
            display = entry.get("display", "")
            if proj and ts:
                # Keep most recent entry per project
                if proj not in projects or ts > projects[proj]["timestamp"]:
                    projects[proj] = {
                        "project": proj,
                        "timestamp": ts,
                        "display": display[:120],
                    }
        except Exception:
            continue
    sorted_projects = sorted(projects.values(), key=lambda x: -x["timestamp"])
    return sorted_projects[:limit]


def get_all_sessions(limit: int = 50) -> list[dict]:
    """Aggregate sessions from all projects' sessions-index.json."""
    sessions = []
    if not PROJECTS_DIR.is_dir():
        return []
    for idx_file in PROJECTS_DIR.glob("*/sessions-index.json"):
        try:
            data = json.loads(idx_file.read_text())
            for entry in data.get("entries", []):
                modified = entry.get("modified")
                if not modified:
                    continue
                sessions.append({
                    "session_id": entry.get("sessionId", ""),
                    "project": entry.get("projectPath", ""),
                    "modified": modified,
                    "first_prompt": (entry.get("firstPrompt") or "")[:120],
                    "messages": entry.get("messageCount", 0),
                })
        except Exception:
            continue
    sessions.sort(key=lambda x: x["modified"], reverse=True)
    return sessions[:limit]


def format_timestamp(ts_ms: int) -> str:
    """Format a millisecond timestamp to a human-readable date."""
    try:
        return datetime.fromtimestamp(ts_ms / 1000).strftime("%Y-%m-%d %H:%M")
    except Exception:
        return "?"


def format_iso_date(iso_str: str) -> str:
    """Format an ISO date string to a shorter form."""
    try:
        dt = datetime.fromisoformat(iso_str.replace("Z", "+00:00"))
        return dt.strftime("%Y-%m-%d %H:%M")
    except Exception:
        return iso_str[:16] if len(iso_str) >= 16 else iso_str


def clean_prompt(text: str) -> str:
    """Strip command markup from prompt text for display."""
    import re
    text = re.sub(r"<[^>]+>", "", text)
    return text.strip()[:100]


# ---------------------------------------------------------------------------
# Confirmation screen
# ---------------------------------------------------------------------------

class ConfirmKillScreen(ModalScreen[bool]):
    """Modal dialog to confirm killing a process."""

    BINDINGS = [
        Binding("y", "confirm", "Yes"),
        Binding("n", "cancel", "No"),
        Binding("escape", "cancel", "Cancel"),
    ]

    def __init__(self, pid: int, directory: str) -> None:
        super().__init__()
        self.pid = pid
        self.directory = directory

    def compose(self) -> ComposeResult:
        yield Vertical(
            Static(f"Kill Claude process PID {self.pid}?", classes="confirm-title"),
            Static(f"Directory: {self.directory}", classes="confirm-detail"),
            Static("[y] Yes  [n] No", classes="confirm-actions"),
            classes="confirm-dialog",
        )

    def action_confirm(self) -> None:
        self.dismiss(True)

    def action_cancel(self) -> None:
        self.dismiss(False)


# ---------------------------------------------------------------------------
# Main app
# ---------------------------------------------------------------------------

class ClaudeActivityApp(App):
    """Claude Activity Dashboard."""

    CSS = """
    Screen {
        background: $surface;
    }

    #active-table, #recent-table, #sessions-table {
        height: 1fr;
    }

    .confirm-dialog {
        dock: bottom;
        height: auto;
        max-height: 8;
        background: $warning-darken-2;
        padding: 1 2;
        border: thick $warning;
    }

    .confirm-title {
        text-style: bold;
        color: $text;
    }

    .confirm-detail {
        color: $text-muted;
    }

    .confirm-actions {
        margin-top: 1;
        text-style: bold;
    }

    #search-bar {
        dock: bottom;
        height: 3;
        display: none;
    }

    #search-bar.visible {
        display: block;
    }
    """

    BINDINGS = [
        Binding("q", "quit", "Quit"),
        Binding("r", "refresh", "Refresh"),
        Binding("x", "kill_process", "Kill"),
        Binding("slash", "search", "Search"),
        Binding("tab", "next_tab", "Next Tab", priority=True),
        Binding("shift+tab", "prev_tab", "Prev Tab", priority=True),
        Binding("escape", "close_search", "Close search", show=False),
    ]

    TITLE = "Claude Activity"

    def compose(self) -> ComposeResult:
        yield Header()
        with TabbedContent("Active", "Recent", "Sessions"):
            with TabPane("Active", id="tab-active"):
                yield DataTable(id="active-table")
            with TabPane("Recent", id="tab-recent"):
                yield DataTable(id="recent-table")
            with TabPane("Sessions", id="tab-sessions"):
                yield DataTable(id="sessions-table")
        yield Input(placeholder="Filter...", id="search-bar")
        yield Footer()

    TAB_IDS = ["tab-active", "tab-recent", "tab-sessions"]

    def action_next_tab(self) -> None:
        tc = self.query_one(TabbedContent)
        current = tc.active or ""
        try:
            idx = self.TAB_IDS.index(current)
            next_id = self.TAB_IDS[(idx + 1) % len(self.TAB_IDS)]
        except ValueError:
            next_id = self.TAB_IDS[0]
        tc.active = next_id

    def action_prev_tab(self) -> None:
        tc = self.query_one(TabbedContent)
        current = tc.active or ""
        try:
            idx = self.TAB_IDS.index(current)
            prev_id = self.TAB_IDS[(idx - 1) % len(self.TAB_IDS)]
        except ValueError:
            prev_id = self.TAB_IDS[0]
        tc.active = prev_id

    def on_mount(self) -> None:
        self._filter_text = ""
        self._load_active()
        self._load_recent()
        self._load_sessions()
        self.query_one("#active-table", DataTable).focus()

    @on(TabbedContent.TabActivated)
    def on_tab_activated(self, event: TabbedContent.TabActivated) -> None:
        """Focus the DataTable when switching tabs."""
        tab_id = event.pane.id or ""
        table_map = {
            "tab-active": "#active-table",
            "tab-recent": "#recent-table",
            "tab-sessions": "#sessions-table",
        }
        target = table_map.get(tab_id)
        if target:
            self.query_one(target).focus()

    @on(DataTable.RowSelected)
    def on_row_selected(self, event: DataTable.RowSelected) -> None:
        """Handle Enter on a table row based on which tab is active."""
        tab_id = self._get_active_tab_id()
        if tab_id == "tab-active":
            self._jump_to_active()
        elif tab_id == "tab-recent":
            self._select_recent()
        elif tab_id == "tab-sessions":
            self._resume_session()

    def _load_active(self) -> None:
        table = self.query_one("#active-table", DataTable)
        table.clear(columns=True)
        table.add_columns("PID", "Directory", "Uptime", "Tmux Location")
        table.cursor_type = "row"
        self._active_data = []
        filter_lower = self._filter_text.lower()
        for proc in get_active_processes():
            if filter_lower:
                searchable = f"{proc['pid']} {proc['directory']} {proc['tmux']}".lower()
                if filter_lower not in searchable:
                    continue
            self._active_data.append(proc)
            table.add_row(
                str(proc["pid"]),
                shorten_path(proc["directory"], max_len=50),
                proc["uptime"],
                proc["tmux"] or "(orphan)",
            )

    def _load_recent(self) -> None:
        table = self.query_one("#recent-table", DataTable)
        table.clear(columns=True)
        table.add_columns("Date", "Project", "Last Prompt")
        table.cursor_type = "row"
        self._recent_data = []
        filter_lower = self._filter_text.lower()
        for proj in get_recent_projects():
            if filter_lower:
                searchable = f"{proj['project']} {proj['display']}".lower()
                if filter_lower not in searchable:
                    continue
            self._recent_data.append(proj)
            table.add_row(
                format_timestamp(proj["timestamp"]),
                shorten_path(proj["project"], max_len=50),
                clean_prompt(proj["display"]),
            )

    def _load_sessions(self) -> None:
        table = self.query_one("#sessions-table", DataTable)
        table.clear(columns=True)
        table.add_columns("Date", "Project", "First Prompt", "Msgs")
        table.cursor_type = "row"
        self._sessions_data = []
        filter_lower = self._filter_text.lower()
        for sess in get_all_sessions():
            if filter_lower:
                searchable = f"{sess['project']} {sess['first_prompt']}".lower()
                if filter_lower not in searchable:
                    continue
            self._sessions_data.append(sess)
            table.add_row(
                format_iso_date(sess["modified"]),
                shorten_path(sess["project"], max_len=45),
                clean_prompt(sess["first_prompt"]),
                str(sess["messages"]),
            )

    def _reload_current_tab(self) -> None:
        tab_id = self._get_active_tab_id()
        if tab_id == "tab-active":
            self._load_active()
        elif tab_id == "tab-recent":
            self._load_recent()
        elif tab_id == "tab-sessions":
            self._load_sessions()

    def action_refresh(self) -> None:
        if self._search_has_focus():
            return
        self._load_active()
        self._load_recent()
        self._load_sessions()
        self.notify("Refreshed")

    def _get_active_tab_id(self) -> str:
        tc = self.query_one(TabbedContent)
        if tc.active:
            return tc.active
        return ""

    def _search_has_focus(self) -> bool:
        return self.query_one("#search-bar", Input).has_focus

    def _get_active_table(self) -> DataTable | None:
        tab_table = {
            "tab-active": "#active-table",
            "tab-recent": "#recent-table",
            "tab-sessions": "#sessions-table",
        }
        selector = tab_table.get(self._get_active_tab_id())
        if selector:
            return self.query_one(selector, DataTable)
        return None

    # --- Vim keybindings ---

    def key_j(self) -> None:
        if not self._search_has_focus():
            table = self._get_active_table()
            if table:
                table.action_cursor_down()

    def key_k(self) -> None:
        if not self._search_has_focus():
            table = self._get_active_table()
            if table:
                table.action_cursor_up()

    def key_h(self) -> None:
        if not self._search_has_focus():
            self.action_prev_tab()

    def key_l(self) -> None:
        if not self._search_has_focus():
            self.action_next_tab()

    def key_g(self) -> None:
        if not self._search_has_focus():
            table = self._get_active_table()
            if table:
                table.move_cursor(row=0)

    def key_upper_g(self) -> None:
        if not self._search_has_focus():
            table = self._get_active_table()
            if table:
                table.move_cursor(row=table.row_count - 1)

    # --- Actions ---

    def action_quit(self) -> None:
        if self._search_has_focus():
            return
        self.exit()

    def action_kill_process(self) -> None:
        if self._search_has_focus():
            return
        if self._get_active_tab_id() != "tab-active":
            self.notify("Kill only works on the Active tab", severity="warning")
            return
        table = self.query_one("#active-table", DataTable)
        if table.cursor_row is None or table.cursor_row >= len(self._active_data):
            return
        proc = self._active_data[table.cursor_row]
        if not proc["pid"]:
            return

        def on_confirm(result: bool) -> None:
            if result:
                try:
                    os.kill(proc["pid"], signal.SIGTERM)
                    self.notify(f"Sent SIGTERM to PID {proc['pid']}")
                    self._load_active()
                except ProcessLookupError:
                    self.notify("Process already exited", severity="warning")
                except PermissionError:
                    self.notify("Permission denied", severity="error")

        self.push_screen(
            ConfirmKillScreen(proc["pid"], proc["directory"]),
            on_confirm,
        )

    def _jump_to_active(self) -> None:
        table = self.query_one("#active-table", DataTable)
        if table.cursor_row is None or table.cursor_row >= len(self._active_data):
            return
        proc = self._active_data[table.cursor_row]
        if not proc["socket"] or not proc["target"]:
            self.notify("No tmux pane found for this process", severity="warning")
            return
        current_socket = get_current_tmux_socket()
        if current_socket and current_socket == proc["socket"]:
            # Same socket — switch-client (seamless)
            subprocess.run(
                ["tmux", "-L", proc["socket"], "switch-client",
                 "-t", proc["target"]],
                timeout=5,
            )
            self.exit()
        elif not current_socket:
            # Not inside tmux — can attach directly
            cmd = f"tmux -L {proc['socket']} attach -t {proc['target']}"
            self.exit(result=("direct", cmd))
        else:
            # Inside tmux, different socket — need to detach first
            cmd = f"tmux -L {proc['socket']} attach -t {proc['target']}"
            self.exit(result=("copy", cmd))

    def _resume_session(self) -> None:
        table = self.query_one("#sessions-table", DataTable)
        if table.cursor_row is None or table.cursor_row >= len(self._sessions_data):
            return
        sess = self._sessions_data[table.cursor_row]
        if not sess["session_id"]:
            self.notify("No session ID found", severity="warning")
            return
        project = sess["project"]
        sid = sess["session_id"]
        current_socket = get_current_tmux_socket()
        if not current_socket:
            cmd = f"cd {project} && claude --resume {sid}"
            self.exit(result=("resume", cmd))
        else:
            self.exit(result=("resume_tmux", (current_socket, project, sid)))

    def _select_recent(self) -> None:
        table = self.query_one("#recent-table", DataTable)
        if table.cursor_row is None or table.cursor_row >= len(self._recent_data):
            return
        proj = self._recent_data[table.cursor_row]
        project = proj["project"]
        current_socket = get_current_tmux_socket()
        if not current_socket:
            cmd = f"cd {project} && claude"
            self.exit(result=("resume", cmd))
        else:
            self.exit(result=("launch_tmux", (current_socket, project)))

    def action_search(self) -> None:
        search_bar = self.query_one("#search-bar", Input)
        search_bar.add_class("visible")
        search_bar.focus()

    def action_close_search(self) -> None:
        search_bar = self.query_one("#search-bar", Input)
        if "visible" in search_bar.classes:
            search_bar.remove_class("visible")
            search_bar.value = ""
            self._filter_text = ""
            self._reload_current_tab()
        else:
            self.exit()

    @on(Input.Changed, "#search-bar")
    def on_search_changed(self, event: Input.Changed) -> None:
        self._filter_text = event.value.strip()
        self._reload_current_tab()

    @on(Input.Submitted, "#search-bar")
    def on_search_submitted(self, event: Input.Submitted) -> None:
        table = self._get_active_table()
        if table:
            table.focus()


if __name__ == "__main__":
    app = ClaudeActivityApp()
    result = app.run()
    if isinstance(result, tuple):
        mode = result[0]
        if mode == "direct":
            args = result[1].split()
            os.execvp(args[0], args)
        elif mode == "copy":
            cmd = result[1]
            copied = copy_to_clipboard(cmd)
            print(f"\n  {cmd}")
            if copied:
                print("  (copied to clipboard — detach with Ctrl-b d, then paste)\n")
            else:
                print("  (detach with Ctrl-b d, then run the command above)\n")
        elif mode == "resume":
            os.execlp("bash", "bash", "-c", result[1])
        elif mode == "resume_tmux":
            socket, project, sid = result[1]
            subprocess.run([
                "tmux", "-L", socket, "new-window", "-c", project,
                "claude", "--resume", sid,
            ], timeout=5)
        elif mode == "launch_tmux":
            socket, project = result[1]
            subprocess.run([
                "tmux", "-L", socket, "new-window", "-c", project,
                "claude",
            ], timeout=5)
