<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <meta name="author" content="Cong Wang" />
  <title>Notation for thinking and reading</title>
  <style type="text/css">code{white-space: pre;}</style>
</head>
<body>
<div id="header">
<h1 class="title">Notation for thinking and reading</h1>
<h2 class="author">Cong Wang</h2>
<h3 class="date">Sun Mar 27 21:24:59 2016</h3>
</div>
<h2 id="notation">Notation</h2>
<ul>
<li><code>?x</code>:= what is <code>x</code> (looking for associated set for manipulating it)?
<ul>
<li>looking for a defined <strong>associated set</strong> which <code>x</code> belongs to;</li>
<li>looking for <strong>definition</strong> of set <code>x</code>;</li>
<li>looking for <strong>description</strong> of entry <code>x</code>;</li>
</ul></li>
<li><code>??x</code>:= why <code>x</code> (looking for a reason)?</li>
<li><code>?&gt;x</code>:= how <code>x</code> (looking for an approach)?</li>
<li><code>?_x</code>:= where/when is <code>x</code> (looking for the state)?</li>
<li><code>?:x</code>:= if <code>x</code> is true?</li>
<li><code>@(?|??|?&gt;|?_|?:)x</code>:= what/which candidates (placeholders/collection/set) for <code>x</code> (while looking for sth as probable solution)? This action can be applied to help decompose different types of questions.<br />
</li>
<li><code>(^[a-z]*[0-9]+)x</code>: mark an question point at <code>$1</code> (you have to check out regex to understand it)</li>
<li><p>Simplify/Summarize what's stated:</p>
<blockquote>
<ul>
<li><code>range + items</code>; The items are usually sets/collections.</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>For example, <code>number + name</code></li>
</ul>
</blockquote></li>
<li><code>:=</code>:= <strong>represent</strong> notation;</li>
<li><code>:</code>:= association notation;</li>
<li><code>,</code>:= list notation;</li>
<li><code>()</code>:=
<ul>
<li>group operator: group things together;</li>
<li><code>var(:parameters)</code>:= parameterize variable <code>var</code>; Interchangable with <code>:</code> association notation;</li>
<li><code>expression(#:comments expression inline)</code>;</li>
<li>function/operation call;</li>
</ul></li>
<li><code>$</code>:= indicates single instance/object;</li>
<li><code>%</code>:= indicates dictionary/mapping;</li>
<li><code>@</code>:= indicates indexed collection/set;</li>
<li><code>A:-$function-&gt;B</code> or <code>A:-$function&gt;B</code>:= indicates a single mapping due to <code>$function</code>;</li>
<li><code>B(:A)</code> or <code>B:=$function(A)</code>:= indicates a single mapping due to <code>$function</code>;</li>
<li><code>A=&gt;B</code>:= if A is true, then B is true;</li>
<li><code>!A</code>:= A is <strong>false</strong>;</li>
<li><p><code>A&lt;&lt;B</code>: A belongs to <strong>set</strong> B. Make catergorization;</p></li>
</ul>
<h2 id="set-theory">Set Theory</h2>
<ul>
<li>Once you can assign a set to something <code>x</code>, you can manipulate <code>x</code> then.</li>
<li>The Set can be context-aware/based.</li>
</ul>
<h2 id="descriptive-vs-relational-operation">Descriptive vs Relational Operation</h2>
<p>Operation can be categorized into two:</p>
<ul>
<li><strong>descriptive</strong>:instance doesn't necessarily have to be changed in a descriptive operation.;</li>
<li><strong>relational</strong>: variables or a set of instances are interested in a relational operation.;</li>
</ul>
<p>In language, verbs don't necessarily indicate a relational operation. For example, A kicks B. B and A don't own a relationship if we regards it as a descriptive operation, in which A and B are just instances and no more than them are interested in a kicking relation. However, in a statement like increasing the invest can win more profit, invest is a variable because it can be increased and profit is a variable because it can be more. This is not a simple description but a relational operation, in which those instance means a bunch of things like different number of invest and different amount of profit.</p>
<h3 id="three-typical-problems-about-pattern-finding-in-relational-operation">Three typical problems about pattern finding in relational operation</h3>
<pre><code>$type1:=?$x:@A:-$x-&gt;@B {
  $isOk=0;
  while ?:(scalar @assumptions&gt;0) {
    $assumption:=shift @assumptions;
    $x:=$assumption;
    @A:-$x-&gt;@B&#39;;
    if @B&#39;==@B {
      $isOk=1;
      break;
    }
  }
  return $isOk, $x; 
}</code></pre>
<pre><code>?$x,@A:@A:-$x-&gt;@B {
  push @A, $more_instance;
  call @A:-$type1-&gt;@B;
}</code></pre>
<pre><code>?$x,@B:@A:-$x-&gt;@B {
  push @B, $more_instance;
  call @B:-$type1-&gt;@A;
}</code></pre>
<h3 id="factoring-a-descriptive-operation">Factoring a descriptive operation</h3>
<p>Parameterizing/Factoring <code>$thing</code> to make its simple description as concrete as an <code>@factors</code>, which are extracted from <code>@instanecs</code>.</p>
<!--
Use natural-language to express idea and reduced-language to look into it.
`x:=Natural Language`;
`y:=Reduced Language`;
Use `$x` to express idea;
Use `$y` to do `@things`;
`@things:={filter possibilities, make question more answerable to the $asked}`;
`%asked`:`query processor`;
`$asked{example}:={"Google", "People who can answer it"}`


### Advanced Workflow

* Build new operator from the old ones;
* to define **Primitive** Operator;
* to define a **Primitive** Set;

To do the last two or not depend on its predictable or reusable purpose, like is it
necessary, or is it simplified?

## More about Notation

* `?x` returns info about which **set/sets** it belongs to and a **description** of
  itself.
* `?>x`: returns steps of doing things.
* *What to do* sth can be converted to `?>make/do sth`?
-->
</body>
</html>
