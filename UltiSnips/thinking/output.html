<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <meta name="author" content="Cong Wang" />
  <title>Notation for thinking and reading</title>
  <style type="text/css">code{white-space: pre;}</style>
</head>
<body>
<div id="header">
<h1 class="title">Notation for thinking and reading</h1>
<h2 class="author">Cong Wang</h2>
<h3 class="date">Sun Mar 27 21:24:59 2016</h3>
</div>
<h2 id="notation">Notation</h2>
<ul>
<li><code>?x</code>:= what is <code>x</code> (looking for associated set for manipulating it)?
<ul>
<li>looking for a defined <strong>associated set</strong> which <code>x</code> belongs to;</li>
<li>looking for <strong>definition</strong> of set <code>x</code>;</li>
<li>looking for <strong>description</strong> of entry <code>x</code>;</li>
</ul></li>
<li><code>??x</code>:= why <code>x</code> (looking for a reason)?</li>
<li><code>?&gt;x</code>:= how <code>x</code> (looking for an approach)?</li>
<li><code>?_x</code>:= where/when is <code>x</code> (looking for the state)?</li>
<li><code>?:x</code>:= if <code>x</code> is true?</li>
<li><code>@(?|??|?&gt;|?_|?:)x</code>:= what/which candidates (placeholders/collection/set) for <code>x</code> (while looking for sth as probable solution)? This action can be applied to help decompose different types of questions.<br />
</li>
<li><code>(^[a-z]*[0-9]+)x</code>: mark an question point at <code>$1</code> (you have to check out regex to understand it)</li>
<li><p>Simplify/Summarize what's stated:</p>
<blockquote>
<ul>
<li><code>range + items</code>; The items are usually sets/collections.</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>For example, <code>number + name</code></li>
</ul>
</blockquote></li>
<li><code>:=</code>:= <strong>represent</strong> notation;</li>
<li><code>:</code>:= association notation;</li>
<li><code>,</code>:= list notation;</li>
<li><code>()</code>:=
<ul>
<li>group operator: group things together;</li>
<li><code>var(:parameters)</code>:= parameterize variable <code>var</code>; Interchangable with <code>:</code> association notation;</li>
<li><code>expression(#:comments expression inline)</code>;</li>
<li>function/operation call;</li>
</ul></li>
<li><code>$</code>:= indicates single instance/object;</li>
<li><code>%</code>:= indicates dictionary/mapping;</li>
<li><code>@</code>:= indicates indexed collection/set;</li>
<li><code>A:-$function-&gt;B</code> or <code>A:-$function&gt;B</code>:= indicates a single mapping due to <code>$function</code>;</li>
<li><code>B(:A)</code> or <code>B:=$function(A)</code>:= indicates a single mapping due to <code>$function</code> in relational operation;</li>
<li><code>B(:A1,A2)</code> could mean <code>A1:-$f1-&gt;B</code>, <code>A2:-$f2-&gt;B</code> or <code>A1,A2:-$f1,$f2-&gt;B</code>. For instance, <code>_:-$f1,$f2-&gt;_ := _:-$f1+$f2-&gt;_</code> .</li>
<li><code>A:-$descriptive_opearator-:B</code>:= indicates a single mapping due to <code>$descriptive_opearator</code> in descriptive operation;</li>
<li><code>A=&gt;B</code>:= if A is true, then B is true;</li>
<li><code>!A</code>:= A is <strong>false</strong>;</li>
<li><p><code>A&lt;&lt;B</code>: A belongs to <strong>set</strong> B. Make catergorization;</p></li>
</ul>
<h2 id="set-theory">Set Theory</h2>
<ul>
<li>Once you can assign a set to something <code>x</code>, you can manipulate <code>x</code> then.</li>
<li>The Set can be context-aware/based.</li>
</ul>
<h2 id="descriptive-vs-relational-operation">Descriptive vs Relational Operation</h2>
<p>Operation can be categorized into two:</p>
<ul>
<li><strong>descriptive</strong>:instance doesn't necessarily have to be changed in a descriptive operation.;</li>
<li><strong>relational</strong>: variables or a set of instances are interested in a relational operation.;</li>
</ul>
<p>In language, verbs don't necessarily indicate a relational operation. For example, A kicks B. B and A don't own a relationship if we regards it as a descriptive operation, in which A and B are just instances and no more than them are interested in a kicking relation. However, in a statement like increasing the invest can win more profit, invest is a variable because it can be increased and profit is a variable because it can be more. This is not a simple description but a relational operation, in which those instance means a bunch of things like different number of invest and different amount of profit.</p>
<h2 id="factoring-a-descriptive-operation">Factoring a descriptive operation</h2>
<p>Parameterizing/Factoring <code>$thing</code> to convert it from something in descriptive operation to an variable in a relational operation by <code>$thing(:@factors)</code> or <code>$thing(#:@factors)</code>, which are extracted from <code>@instanecs</code>.</p>
<h2 id="symbolize-make-an-instance-be-replaced-by-a-placeholder-in-the-form-of-a-symbol">Symbolize: make an instance be replaced by a placeholder in the form of a symbol</h2>
<pre><code>  &quot;my description&quot;:-symbolize-&gt;$x; 
  $x:-value-&gt;&quot;my description&quot;;</code></pre>
<h2 id="declaration-evaluation">Declaration, Evaluation</h2>
<p><strong>Automation</strong> is only about <strong>declaration</strong>, <strong>evaluation</strong> and <strong>context</strong>.</p>
<!--
EXAMPLE

?$x=>$x:-used as-:$"a tag for email from lela";

$s(:$y);

@y:"people in research":={
  lela:@{kral, group, a professor in university, md, 
  },
  henry:@{kral group, researcher in Argone lab},
  han:@{kral group, lab mate},
  sanoj:@{kral group, lab mate},
  petr:@{advisor, professor in university},
};

So, the problem type is the 3rd one. I need to find more instances
about $"a tag for email from lela". 

-->
<!--

### Two typical problems about pattern finding in relational operation

```
$type1:=?$x=>@A:-$x->@B {
  $isOk=0;
  while ?:(scalar @assumptions>0) {
    $assumption:=shift @assumptions;
    $x:=$assumption;
    @A:-$x->@B';
    if @B'==@B {
      $isOk=1;
      break;
    }
  }
  return $isOk, $x; 
}
```

```
$type3:=?$x,@B=>@A:-$x->@B {
  push @B, $more_instance;
  call @B:-$type1->@A;
}
```


-->
<!--
Use natural-language to express idea and reduced-language to look into it.
`x:=Natural Language`;
`y:=Reduced Language`;
Use `$x` to express idea;
Use `$y` to do `@things`;
`@things:={filter possibilities, make question more answerable to the $asked}`;
`%asked`:`query processor`;
`$asked{example}:={"Google", "People who can answer it"}`


### Advanced Workflow

* Build new operator from the old ones;
* to define **Primitive** Operator;
* to define a **Primitive** Set;

To do the last two or not depend on its predictable or reusable purpose, like is it
necessary, or is it simplified?

## More about Notation

* `?x` returns info about which **set/sets** it belongs to and a **description** of
  itself.
* `?>x`: returns steps of doing things.
* *What to do* sth can be converted to `?>make/do sth`?
-->
<!--
interfaces can not be changed during usage.
parameterize vs varize (find more instance about an variable)
-->
</body>
</html>
